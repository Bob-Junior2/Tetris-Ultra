<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>TETRIS ULTRA v4.0</title>

    <!-- 
      TETRIS ULTRA v4.0: Cinematic Edition + Global Leaderboard
      
      V4.0 UPGRADES:
      - Replaced localStorage leaderboard with Dreamlo Global Leaderboard.
      - Added score submission to Dreamlo on game over.
      - Added score fetching from Dreamlo for the leaderboard screen.
      - Added new "top-3" glowing style for the leaderboard.
      - Kept 10-character name limit.

      V3.3 UPGRADES:
      - Added 3D camera tilt with gesture/mouse control.
      - Added new 3D positional audio for music (bass/ambient).
      - Added mobile gesture controls (swipe/tap).
      - Added combo aura effect to game canvas.
    -->

    <style>
        /* --- 1. GLOBAL & FONT --- */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --font-main: 'Orbitron', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', sans-serif;
            
            /* Themeable Colors */
            --color-primary: #00ffff;
            --color-secondary: #ff00ff;
            --color-tertiary: #ffff00;
            --color-light: #ffffff;
            
            /* Base Colors */
            --color-bg-deep: #0a0a1a;
            --color-bg-mid: #10102a;
            --color-bg-light: #1a1a3a;
            
            /* Text */
            --text-primary: var(--color-light);
            --text-accent: var(--color-primary);
            --text-dim: #a0a0c0;

            /* UI */
            --border-radius-s: 4px;
            --border-radius-m: 8px;
            --border-radius-l: 16px;
            
            /* Cursor Light */
            --mouse-x: 50%;
            --mouse-y: 50%;
            --cursor-light-size: 400px;
            
            /* New: Camera Tilt */
            --camera-rotate-y: -3deg; /* Default tilt */
            --camera-rotate-x: 3deg;  /* Default tilt */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--color-bg-deep);
            color: var(--text-primary);
            font-family: var(--font-main);
            user-select: none;
            /* Interactive Cursor Light */
            background-image: radial-gradient(
                circle var(--cursor-light-size) at var(--mouse-x) var(--mouse-y),
                rgba(255, 255, 255, 0.05),
                transparent
            );
            transition: --cursor-light-size 0.3s ease-out;
            
            /* New: 3D Perspective */
            perspective: 2000px;
        }
        
        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            /* New: 3D Transform */
            transform-style: preserve-3d;
            transition: transform 0.1s linear;
            transform: rotateX(var(--camera-rotate-x)) rotateY(var(--camera-rotate-y));
        }

        h1, h2, h3 {
            text-transform: uppercase;
            font-weight: 700;
            text-shadow: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary);
        }

        /* --- 2. KEYFRAME ANIMATIONS --- */

        @keyframes pulse {
            0% { text-shadow: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary); transform: scale(1); }
            50% { text-shadow: 0 0 10px var(--color-secondary), 0 0 20px var(--color-secondary); transform: scale(1.02); }
            100% { text-shadow: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary); transform: scale(1); }
        }
        @keyframes glow {
            0% { box-shadow: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary) inset, 0 0 5px var(--color-primary); border-color: var(--color-primary); }
            50% { box-shadow: 0 0 10px var(--color-secondary), 0 0 20px var(--color-secondary) inset, 0 0 10px var(--color-secondary); border-color: var(--color-secondary); }
            100% { box-shadow: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary) inset, 0 0 5px var(--color-primary); border-color: var(--color-primary); }
        }
        @keyframes gameOverGlow {
            0% { text-shadow: 0 0 10px #f00, 0 0 20px #f00; }
            50% { text-shadow: 0 0 20px #f00, 0 0 40px #f00; transform: scale(1.05); }
            100% { text-shadow: 0 0 10px #f00, 0 0 20px #f00; }
        }
        @keyframes screenShake {
            0% { transform: translateZ(0) translate(0, 0) rotate(0); } 
            10% { transform: translateZ(10px) translate(-2px, 2px) rotate(-0.1deg); }
            20% { transform: translateZ(5px) translate(2px, -2px) rotate(0.1deg); } 
            30% { transform: translateZ(0) translate(-2px, 2px) rotate(0.1deg); }
            40% { transform: translateZ(5px) translate(2px, -2px) rotate(-0.1deg); } 
            50% { transform: translateZ(10px) translate(-2px, -2px) rotate(-0.1deg); }
            60% { transform: translateZ(5px) translate(2px, 2px) rotate(0.1deg); } 
            70% { transform: translateZ(0) translate(-2px, 2px) rotate(-0.1deg); }
            80% { transform: translateZ(5px) translate(2px, -2px) rotate(0.1deg); } 
            90% { transform: translateZ(10px) translate(-2px, 2px) rotate(0); }
            100% { transform: translateZ(0) translate(0, 0) rotate(0); }
        }
        
        @keyframes logoReveal {
            from { opacity: 0; filter: blur(15px); transform: scale(1.5) translateZ(50px); text-shadow: 0 0 10px var(--color-light), 0 0 20px var(--color-light); }
            to { opacity: 1; filter: blur(0); transform: scale(1) translateZ(0); text-shadow: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary); }
        }

        @keyframes slideInAndOut { 0% { transform: translateX(110%); opacity: 0; } 10% { transform: translateX(0); opacity: 1; } 90% { transform: translateX(0); opacity: 1; } 100% { transform: translateX(110%); opacity: 0; } }
        
        /* New: Combo Aura */
        @keyframes comboAura {
            0% { box-shadow: 0 0 20px var(--color-primary), 0 0 30px var(--color-primary) inset; }
            50% { box-shadow: 0 0 30px var(--color-tertiary), 0 0 45px var(--color-tertiary) inset; }
            100% { box-shadow: 0 0 20px var(--color-primary), 0 0 30px var(--color-primary) inset; }
        }

        /* New: Top 3 Glow */
        @keyframes top3Glow {
            0% { box-shadow: 0 0 10px var(--color-tertiary), 0 0 5px var(--color-tertiary) inset; border-color: var(--color-tertiary); }
            50% { box-shadow: 0 0 20px var(--color-light), 0 0 10px var(--color-light) inset; border-color: var(--color-light); }
            100% { box-shadow: 0 0 10px var(--color-tertiary), 0 0 5px var(--color-tertiary) inset; border-color: var(--color-tertiary); }
        }

        /* --- 3. MAIN LAYOUT & CONTAINERS --- */

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s ease-out;
            transform-style: preserve-3d; /* For screen shake */
        }
        
        #game-container.shake {
            animation: screenShake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        #background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.6;
            /* Parallax transition */
            transition: transform 0.2s cubic-bezier(0, 0, 0.5, 1);
            /* Move back in 3D space */
            transform: translateZ(-500px) scale(1.5);
        }
        
        /* Beat-responsive pulse for borders */
        .beat-pulse {
            transition: box-shadow 0.05s ease-in, border-color 0.05s ease-in;
            transform: translateZ(0); /* Promote to 3D layer */
        }
        body.beat-active .beat-pulse {
            box-shadow: 0 0 25px var(--color-primary), 0 0 40px var(--color-primary) inset, 0 0 25px var(--color-primary);
            border-color: var(--color-light);
            transition: box-shadow 0.1s ease-out, border-color 0.1s ease-out;
        }

        /* Screen Manager (Transitions) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 10;
            opacity: 0;
            transform: scale(1.05) translateZ(50px); /* 3D transition */
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            transform-style: preserve-3d;
        }
        .screen.active {
            opacity: 1;
            transform: scale(1) translateZ(0);
            pointer-events: auto;
        }
        .screen.fade-out {
            opacity: 0;
            transform: scale(0.95) translateZ(-50px);
            pointer-events: none;
        }

        /* Glassmorphism UI Panel */
        .modal-panel {
            background: rgba(0, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid var(--color-primary);
            border-radius: var(--border-radius-l);
            padding: 2rem 3rem;
            box-shadow: 0 0 20px var(--color-primary), 0 0 30px var(--color-primary) inset;
            animation: glow 6s infinite alternate;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-width: 300px;
            max-width: 90vw;
            transform: translateZ(10px); /* Lift panel */
        }

        .modal-panel h2 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 1rem;
            color: var(--color-primary);
        }

        /* --- 4. UI ELEMENTS --- */

        .neon-button {
            background: transparent;
            border: 2px solid var(--color-primary);
            color: var(--color-primary);
            padding: 0.8rem 1.5rem;
            font-family: var(--font-main);
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: var(--border-radius-m);
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px var(--color-primary);
            box-shadow: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary) inset;
            width: 100%;
            text-align: center;
            transform: translateZ(0); /* 3D layer */
        }
        .neon-button:hover, .neon-button:focus {
            background: var(--color-primary); color: var(--color-bg-deep);
            box-shadow: 0 0 10px var(--color-primary), 0 0 20px var(--color-primary), 0 0 30px var(--color-primary);
            text-shadow: none; outline: none;
            transform: scale(1.02) translateZ(5px); /* Lift on hover */
        }
        .neon-button.secondary {
            border-color: var(--color-secondary); color: var(--color-secondary);
            text-shadow: 0 0 5px var(--color-secondary);
            box-shadow: 0 0 5px var(--color-secondary), 0 0 10px var(--color-secondary) inset;
        }
        .neon-button.secondary:hover, .neon-button.secondary:focus {
            background: var(--color-secondary); color: var(--color-bg-deep);
            box-shadow: 0 0 10px var(--color-secondary), 0 0 20px var(--color-secondary), 0 0 30px var(--color-secondary);
        }

        /* Settings Controls */
        .setting-row { display: flex; justify-content: space-between; align-items: center; gap: 1rem; width: 100%; }
        .setting-row label { font-size: 1rem; font-weight: 700; color: var(--text-dim); text-transform: uppercase; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .toggle-switch input { display: none; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--color-bg-light); border: 1px solid var(--color-primary); transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: var(--color-primary); transition: .4s; border-radius: 50%; box-shadow: 0 0 5px var(--color-primary); }
        input:checked + .slider { background-color: var(--color-primary); box-shadow: 0 0 10px var(--color-primary) inset; }
        input:checked + .slider:before { transform: translateX(26px); background-color: var(--color-bg-deep); box-shadow: none; }
        .neon-select { background: transparent; border: 2px solid var(--color-primary); color: var(--color-primary); padding: 0.5rem; font-family: var(--font-main); font-size: 1rem; font-weight: 700; border-radius: var(--border-radius-s); box-shadow: 0 0 5px var(--color-primary) inset; }
        .neon-select option { background: var(--color-bg-mid); color: var(--text-primary); }
        .neon-input { background: rgba(0,0,0,0.2); border: 2px solid var(--color-primary); color: var(--color-primary); padding: 0.8rem; font-family: var(--font-main); font-size: 1.2rem; font-weight: 700; border-radius: var(--border-radius-m); box-shadow: 0 0 5px var(--color-primary) inset; width: 100%; text-align: left; text-transform: uppercase; }
        .neon-input::placeholder { color: var(--color-primary); opacity: 0.5; }
        .neon-input:focus { outline: none; box-shadow: 0 0 5px var(--color-primary) inset, 0 0 10px var(--color-primary); }

        /* --- 5. SPECIFIC SCREEN STYLES --- */

        /* Start Screen */
        #start-screen {
            gap: 2rem;
        }
        .logo-title {
            font-size: 5rem;
            font-weight: 900;
            color: var(--color-light);
            text-align: center;
            line-height: 1;
            transform-style: preserve-3d;
        }
        .logo-part {
            display: inline-block;
            opacity: 0;
            filter: blur(15px);
            transform: scale(1.5) translateZ(50px);
        }
        .screen.active .logo-part.logo-tetris {
            animation: logoReveal 1s 0.2s ease-out forwards;
        }
        .screen.active .logo-part.logo-ultra {
            animation: logoReveal 1s 0.5s ease-out forwards;
        }
        .screen.active #start-screen-buttons {
            animation: logoReveal 1s 0.8s ease-out forwards;
            opacity: 0;
        }
        #start-screen-buttons {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 250px;
        }

        /* Game Over, Leaderboard, How-to-Play */
        #game-over-screen h2 { font-size: 4rem; color: #ff0000; animation: gameOverGlow 2s infinite ease-in-out; }
        #final-score-display { font-size: 1.5rem; color: var(--color-tertiary); text-shadow: 0 0 5px var(--color-tertiary); text-align: center; }
        #leaderboard-entry { width: 100%; display: flex; flex-direction: column; gap: 1rem; }
        #leaderboard-list { list-style: none; width: 100%; display: flex; flex-direction: column; gap: 1rem; max-height: 40vh; overflow-y: auto; }
        #leaderboard-list li { display: flex; justify-content: space-between; font-size: 1.2rem; padding: 0.5rem 1rem; background: rgba(0, 255, 255, 0.1); border-radius: var(--border-radius-s); border: 1px solid rgba(0, 255, 255, 0.2); transition: all 0.3s ease; }
        #leaderboard-list li .score { color: var(--color-tertiary); font-weight: 700; }
        #leaderboard-list li .rank { color: var(--color-primary); font-weight: 700; min-width: 2rem; }
        #leaderboard-list li .name { flex-grow: 1; margin-left: 1rem; color: var(--text-dim); }

        /* New: Top 3 Styling */
        #leaderboard-list li.top-3 {
            border-color: var(--color-tertiary);
            background: rgba(255, 255, 0, 0.1);
            animation: top3Glow 2s infinite alternate;
        }

        /* How to Play */
        #how-to-play-content { display: flex; flex-direction: column; gap: 1.5rem; color: var(--text-dim); font-size: 1rem; }
        .control-row { display: flex; align-items: center; gap: 1rem; }
        .control-key { background: var(--color-bg-light); border: 1px solid var(--color-primary); border-radius: var(--border-radius-s); padding: 0.5rem 0.8rem; font-family: var(--font-main); color: var(--color-primary); font-weight: 700; min-width: 40px; text-align: center; }
        .control-desc { font-size: 1.1rem; color: var(--text-primary); }

        /* --- 6. GAME PLAY SCREEN & LAYOUT --- */

        #game-play-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
            transform-style: preserve-3d;
        }

        #game-canvas {
            background: rgba(0, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            border: 2px solid var(--color-primary);
            border-radius: var(--border-radius-m);
            box-shadow: 0 0 20px var(--color-primary), 0 0 30px var(--color-primary) inset;
            transform: translateZ(0); /* 3D layer */
        }
        
        /* New: Combo Aura */
        #game-canvas.combo-active {
            animation: comboAura 1.5s infinite alternate;
        }
        
        #game-info-panel-left,
        #game-info-panel-right {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 200px;
            transform-style: preserve-3d;
        }
        /* Tilt panels */
        #game-info-panel-left { transform: rotateY(20deg) translateZ(10px); }
        #game-info-panel-right { transform: rotateY(-20deg) translateZ(10px); }

        .info-box {
            background: rgba(0, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 2px solid var(--color-primary);
            border-radius: var(--border-radius-m);
            padding: 1rem;
            text-align: center;
            box-shadow: 0 0 10px var(--color-primary) inset;
            transition: transform 0.3s ease;
        }
        .info-box:hover {
            transform: scale(1.03) translateZ(15px);
        }
        .info-box h3 { font-size: 1rem; color: var(--color-primary); margin-bottom: 0.5rem; text-shadow: 0 0 5px var(--color-primary); }
        .info-box-value { font-size: 2rem; font-weight: 700; color: var(--color-light); text-shadow: 0 0 5px var(--color-light); }
        
        .info-box-canvas {
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid var(--color-primary);
            border-radius: var(--border-radius-m);
            box-shadow: 0 0 10px var(--color-primary) inset;
        }
        
        /* --- 7. ACHIEVEMENT UI --- */
        
        #achievement-popup {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 0, 0.1);
            backdrop-filter: blur(15px);
            border: 2px solid var(--color-tertiary);
            border-radius: var(--border-radius-m);
            padding: 1.5rem;
            box-shadow: 0 0 20px var(--color-tertiary), 0 0 30px var(--color-tertiary) inset;
            color: var(--color-tertiary);
            transform: translateX(110%);
            opacity: 0;
            transition: all 0.5s ease-out;
        }
        #achievement-popup.show { animation: slideInAndOut 5s ease-in-out forwards; }
        #achievement-popup h3 { font-size: 1.2rem; color: var(--color-light); text-shadow: 0 0 5px var(--color-light); }
        #achievement-popup p { font-size: 1rem; color: var(--color-tertiary); }


        /* --- 8. MOBILE/RESPONSIVE STYLES --- */

        #touch-controls {
            display: none; /* Hidden by default, enabled by JS */
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            z-index: 100;
            padding: 0 20px;
            transform: translateZ(20px);
        }
        .touch-grid { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 10px; width: 100%; max-width: 500px; margin: 0 auto; opacity: 0.7; }
        .touch-button { background: rgba(0, 255, 255, 0.2); border: 2px solid var(--color-primary); border-radius: var(--border-radius-l); color: var(--color-primary); font-family: var(--font-main); font-size: 1.5rem; font-weight: 700; padding: 1rem; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 10px var(--color-primary) inset; }
        #touch-rotate { grid-column: 4 / 5; grid-row: 1 / 3; }
        #touch-hold { grid-column: 1 / 2; grid-row: 1 / 3; }
        #touch-left { grid-column: 2 / 3; grid-row: 2 / 3; }
        #touch-right { grid-column: 3 / 4; grid-row: 2 / 3; }
        #touch-down { grid-column: 2 / 4; grid-row: 1 / 2; }
        #touch-drop { display: none; } /* Replaced by swipe down */

        
        @media (max-width: 860px) {
            .logo-title { font-size: 3.5rem; }
            .modal-panel { padding: 1.5rem; width: 90vw; max-height: 90vh; overflow-y: auto; }
            .modal-panel h2 { font-size: 2rem; }
            #game-play-screen { flex-direction: column; padding: 10px; gap: 10px; justify-content: flex-start; padding-top: 5vh; }
            
            /* Untilt panels for mobile */
            #game-info-panel-left { order: 1; width: 100%; max-width: 400px; flex-direction: row; justify-content: space-around; transform: none; }
            #game-info-panel-right { order: 1; width: 100%; max-width: 400px; flex-direction: row; justify-content: space-around; transform: none; }
            
            #game-canvas { order: 2; }
            .info-box { flex: 1; padding: 0.5rem; }
            .info-box-value { font-size: 1.5rem; }
            .info-box h3 { font-size: 0.8rem; }
            #score-box { flex-grow: 2; }
            #hold-piece-box, #next-piece-box { display: flex; flex-direction: column; align-items: center; justify-content: center; }
            #hold-piece-canvas, #next-piece-canvas { width: 80px !important; height: 80px !important; }
            /* #touch-controls { display: block; } */ /* JS will handle this */
            #pause-game-btn { display: block; position: absolute; top: 10px; right: 10px; z-index: 101; width: 50px; height: 50px; font-size: 1.5rem; padding: 0; }
            #achievement-popup { top: auto; bottom: 150px; left: 50%; transform: translateX(-50%) translateY(110%); width: 90vw; }
            @keyframes slideInAndOut {
                0% { transform: translateX(-50%) translateY(110%); opacity: 0; }
                10% { transform: translateX(-50%) translateY(0); opacity: 1; }
                90% { transform: translateX(-50%) translateY(0); opacity: 1; }
                100% { transform: translateX(-50%) translateY(110%); opacity: 0; }
            }
        }
        
        @media (max-height: 500px) and (min-width: 861px) {
             #game-play-screen { flex-direction: row; justify-content: center; align-items: flex-start; padding-top: 10px; }
             #game-info-panel-left, #game-info-panel-right { flex-direction: column; width: 150px; transform: none; }
             #game-canvas { order: 0; }
             #touch-controls { display: none; }
        }

    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="game-container">
            
            <canvas id="background-canvas"></canvas>
            
            <div id="game-play-screen" class="screen">
                <button id="pause-game-btn" class="neon-button" style="display: none;">||</button>
                
                <div id="game-info-panel-left">
                    <div id="hold-piece-box" class="info-box beat-pulse">
                        <h3>Hold</h3>
                        <canvas id="hold-piece-canvas" class="info-box-canvas"></canvas>
                    </div>
                     <div class="info-box beat-pulse">
                        <h3>Level</h3>
                        <div id="level-value" class="info-box-value">1</div>
                    </div>
                </div>
                
                <canvas id="game-canvas" class="beat-pulse"></canvas>

                <div id="game-info-panel-right">
                    <div id="score-box" class="info-box beat-pulse">
                        <h3>Score</h3>
                        <div id="score-value" class="info-box-value">0</div>
                    </div>
                    
                    <div id="next-piece-box" class="info-box beat-pulse">
                        <h3>Next</h3>
                        <canvas id="next-piece-canvas" class="info-box-canvas"></canvas>
                    </div>

                    <div class="info-box beat-pulse">
                        <h3>Lines</h3>
                        <div id="lines-value" class="info-box-value">0</div>
                    </div>
                    
                    <div class="info-box beat-pulse">
                        <h3>Combo</h3>
                        <div id="combo-value" class="info-box-value">0</div>
                    </div>
                </div>
            </div>
            
            <div id="touch-controls">
                <div class="touch-grid">
                    <button id="touch-hold" class="touch-button">H</button>
                    <button id="touch-down" class="touch-button">&#x2193;</button>
                    <button id="touch-rotate" class="touch-button">&#x21BB;</button>
                    <button id="touch-left" class="touch-button">&#x2190;</button>
                    <button id="touch-right" class="touch-button">&#x2192;</button>
                </div>
            </div>

            <div id="start-screen" class="screen">
                <h1 class="logo-title">
                    <span class="logo-part logo-tetris">TETRIS</span><br>
                    <span class="logo-part logo-ultra">ULTRA</span>
                </h1>
                <div id="start-screen-buttons">
                    <button id="start-play-btn" class="neon-button">Play</button>
                    <button id="start-settings-btn" class="neon-button secondary">Settings</button>
                </div>
            </div>

            <div id="main-menu-screen" class="screen">
                <div class="modal-panel beat-pulse">
                    <h2>Main Menu</h2>
                    <button id="menu-new-game-btn" class="neon-button">New Game</button>
                    <button id="menu-leaderboard-btn" class="neon-button">Leaderboard</button>
                    <button id="menu-how-to-play-btn" class="neon-button">How to Play</button>
                    <button id="menu-settings-btn" class="neon-button">Settings</button>
                    <button id="menu-achievements-btn" class="neon-button">Achievements</button>
                </div>
            </div>
            
            <div id="pause-screen" class="screen">
                <div class="modal-panel beat-pulse">
                    <h2>Paused</h2>
                    <button id="pause-resume-btn" class="neon-button">Resume</button>
                    <button id="pause-restart-btn" class="neon-button">Restart</button>
                    <button id="pause-quit-btn" class="neon-button secondary">Quit to Menu</button>
                </div>
            </div>
            
            <div id="game-over-screen" class="screen">
                <div class="modal-panel"> <!-- beat-pulse removed -->
                    <h2>Game Over</h2>
                    <div id="final-score-display">Final Score: 12345</div>
                    <div id="leaderboard-entry">
                        <label for="player-name-input">Enter Your Name (10 Chars):</label>
                        <input type="text" id="player-name-input" class="neon-input" maxlength="10" placeholder="PLAYER">
                        <button id="submit-score-btn" class="neon-button">Save Score</button>
                    </div>
                    <button id="game-over-restart-btn" class="neon-button">Restart</button>
                    <button id="game-over-quit-btn" class="neon-button secondary">Back to Menu</button>
                </div>
            </div>
            
            <div id="leaderboard-screen" class="screen">
                <div class="modal-panel beat-pulse">
                    <h2>Leaderboard</h2>
                    <ul id="leaderboard-list"></ul>
                    <button id="leaderboard-back-btn" class="neon-button">Back</button>
                </div>
            </div>
            
            <div id="achievements-screen" class="screen">
                <div class="modal-panel beat-pulse">
                    <h2>Achievements</h2>
                    <ul id="achievements-list"></ul>
                    <button id="achievements-back-btn" class="neon-button">Back</button>
                </div>
            </div>
            
            <div id="settings-screen" class="screen">
                <div class="modal-panel beat-pulse">
                    <h2>Settings</h2>
                    <div class="setting-row">
                        <label for="sound-toggle">Sound FX</label>
                        <label class="toggle-switch"><input type="checkbox" id="sound-toggle" checked><span class="slider"></span></label>
                    </div>
                    <div class="setting-row">
                        <label for="music-toggle">Music</label>
                        <label class="toggle-switch"><input type="checkbox" id="music-toggle" checked><span class="slider"></span></label>
                    </div>
                    <div class="setting-row">
                        <label for="difficulty-select">Difficulty</label>
                        <select id="difficulty-select" class="neon-select">
                            <option value="easy">Easy</option><option value="normal" selected>Normal</option><option value="hard">Hard</option><option value="ultra">ULTRA</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label for="theme-select">Block Theme</label>
                        <select id="theme-select" class="neon-select">
                            <option value="neon" selected>Neon</option><option value="cyberpunk">Cyberpunk</option><option value="retro">Retro</option><option value="pastel">Pastel</option><option value="mono">Mono</option>
                        </select>
                    </div>
                    <button id="settings-back-btn" class="neon-button">Back</button>
                </div>
            </div>
            
            <div id="how-to-play-screen" class="screen">
                <div class="modal-panel beat-pulse">
                    <h2>How to Play</h2>
                    <div id="how-to-play-content">
                        <div class="control-row"><span class="control-key">&larr;</span> / <span class="control-key">&rarr;</span><span class="control-desc">Move Left / Right</span></div>
                        <div class="control-row"><span class="control-key">&darr;</span><span class="control-desc">Soft Drop</span></div>
                        <div class="control-row"><span class="control-key">&uarr;</span> / <span class="control-key">X</span><span class="control-desc">Rotate Clockwise</span></div>
                        <div class="control-row"><span class="control-key">Z</span><span class="control-desc">Rotate C-Clockwise</span></div>
                        <div class="control-row"><span class="control-key">Space</span><span class="control-desc">Hard Drop</span></div>
                        <div class="control-row"><span class="control-key">C</span> / <span class="control-key">Shift</span><span class="control-desc">Hold Piece</span></div>
                        <div class="control-row"><span class="control-key">P</span><span class="control-desc">Pause Game</span></div>
                        <div class="control-row"><span class="control-key">R</span><span class="control-desc">Restart Game</span></div>
                        <br>
                        <div class="control-desc">Mobile: Use on-screen buttons or gestures (swipe left/right, swipe down, tap).</div>
                    </div>
                    <button id="how-to-play-back-btn" class="neon-button">Back</button>
                </div>
            </div>

        </div> <!-- End #game-container -->

        <div id="achievement-popup">
            <h3 id="achievement-title">Achievement Unlocked!</h3>
            <p id="achievement-desc">You did a cool thing!</p>
        </div>
        
    </div> <!-- End #game-wrapper -->


    <!-- 
      ******************************************************************
      *** JAVASCRIPT LOGIC (v4.0)               ***
      ******************************************************************
    -->
    <script>
        window.addEventListener('DOMContentLoaded', () => {

            // --- 1. DOM ELEMENT SELECTION ---
            const gameWrapper = document.getElementById('game-wrapper'); // New for 3D tilt
            const gameContainer = document.getElementById('game-container');
            const gameCanvas = document.getElementById('game-canvas');
            const gameCtx = gameCanvas.getContext('2d');
            const nextCanvas = document.getElementById('next-piece-canvas');
            const nextCtx = nextCanvas.getContext('2d');
            const holdCanvas = document.getElementById('hold-piece-canvas');
            const holdCtx = holdCanvas.getContext('2d');
            const bgCanvas = document.getElementById('background-canvas');
            const bgCtx = bgCanvas.getContext('2d');
            const screens = {
                start: document.getElementById('start-screen'),
                menu: document.getElementById('main-menu-screen'),
                game: document.getElementById('game-play-screen'),
                pause: document.getElementById('pause-screen'),
                gameOver: document.getElementById('game-over-screen'),
                leaderboard: document.getElementById('leaderboard-screen'),
                settings: document.getElementById('settings-screen'),
                howToPlay: document.getElementById('how-to-play-screen'),
                achievements: document.getElementById('achievements-screen'),
            };
            const buttons = {
                startPlay: document.getElementById('start-play-btn'),
                startSettings: document.getElementById('start-settings-btn'),
                menuNewGame: document.getElementById('menu-new-game-btn'),
                menuLeaderboard: document.getElementById('menu-leaderboard-btn'),
                menuHowToPlay: document.getElementById('menu-how-to-play-btn'),
                menuSettings: document.getElementById('menu-settings-btn'),
                menuAchievements: document.getElementById('menu-achievements-btn'),
                pauseResume: document.getElementById('pause-resume-btn'),
                pauseRestart: document.getElementById('pause-restart-btn'),
                pauseQuit: document.getElementById('pause-quit-btn'),
                gameOverRestart: document.getElementById('game-over-restart-btn'),
                gameOverQuit: document.getElementById('game-over-quit-btn'),
                submitScore: document.getElementById('submit-score-btn'),
                leaderboardBack: document.getElementById('leaderboard-back-btn'),
                settingsBack: document.getElementById('settings-back-btn'),
                howToPlayBack: document.getElementById('how-to-play-back-btn'),
                achievementsBack: document.getElementById('achievements-back-btn'),
                pauseGame: document.getElementById('pause-game-btn'),
            };
            const ui = {
                score: document.getElementById('score-value'),
                level: document.getElementById('level-value'),
                lines: document.getElementById('lines-value'),
                combo: document.getElementById('combo-value'),
                finalScore: document.getElementById('final-score-display'),
                playerNameInput: document.getElementById('player-name-input'),
                leaderboardList: document.getElementById('leaderboard-list'),
                achievementsList: document.getElementById('achievements-list'),
                achievementPopup: document.getElementById('achievement-popup'),
                achievementTitle: document.getElementById('achievement-title'),
                achievementDesc: document.getElementById('achievement-desc'),
            };
            const settings = {
                sound: document.getElementById('sound-toggle'),
                music: document.getElementById('music-toggle'),
                difficulty: document.getElementById('difficulty-select'),
                theme: document.getElementById('theme-select'),
            };
            const touch = {
                controls: document.getElementById('touch-controls'),
                left: document.getElementById('touch-left'),
                right: document.getElementById('touch-right'),
                down: document.getElementById('touch-down'),
                rotate: document.getElementById('touch-rotate'),
                hold: document.getElementById('touch-hold'),
            };

            
            // --- 2. GAME CONSTANTS & THEMES ---
            const COLS = 10; const ROWS = 20; let BLOCK_SIZE = 30;
            const NEXT_CANVAS_SIZE = 120; const HOLD_CANVAS_SIZE = 120;
            const PIECES = [
                { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], name: 'I' },
                { shape: [[2,2],[2,2]], name: 'O' },
                { shape: [[0,3,0],[3,3,3],[0,0,0]], name: 'T' },
                { shape: [[4,0,0],[4,4,4],[0,0,0]], name: 'J' },
                { shape: [[0,0,5],[5,5,5],[0,0,0]], name: 'L' },
                { shape: [[0,6,6],[6,6,0],[0,0,0]], name: 'S' },
                { shape: [[7,7,0],[0,7,7],[0,0,0]], name: 'Z' }
            ];
            const THEMES = {
                neon: { 0: '#00000000', 1: '#00ffff', 2: '#ffff00', 3: '#ff00ff', 4: '#0000ff', 5: '#ff7f00', 6: '#00ff00', 7: '#ff0000', grid: '#1a1a3a', background: '#0a0a1a' },
                cyberpunk: { 0: '#00000000', 1: '#f000ff', 2: '#00f0ff', 3: '#ff0055', 4: '#a000ff', 5: '#00ff90', 6: '#fff000', 7: '#0070ff', grid: '#200020', background: '#0a000a' },
                retro: { 0: '#00000000', 1: '#e08040', 2: '#60e0a0', 3: '#d060c0', 4: '#e0c040', 5: '#5060e0', 6: '#c04040', 7: '#70e040', grid: '#303030', background: '#000000' },
                pastel: { 0: '#00000000', 1: '#fd9ab2', 2: '#f0c05a', 3: '#a8d3e6', 4: '#c5a9de', 5: '#f8e6b1', 6: '#a2e0c0', 7: '#f5b5b5', grid: '#e0e0f0', background: '#f0f0ff' },
                mono: { 0: '#00000000', 1: '#ffffff', 2: '#e0e0e0', 3: '#c0c0c0', 4: '#a0a0a0', 5: '#808080', 6: '#606060', 7: '#404040', grid: '#202020', background: '#000000' }
            };
            let currentTheme = THEMES.neon;
            const DIFFICULTIES = { easy: 1000, normal: 700, hard: 400, ultra: 200 };
            let baseDropInterval = DIFFICULTIES.normal;
            const SCORE_VALUES = { single: 100, double: 300, triple: 500, tetris: 800, tspin: 400, tspinSingle: 800, tspinDouble: 1200, tspinTriple: 1600, perfectClear: 3000, combo: 50, softDrop: 1, hardDrop: 2 };
            const LINES_PER_LEVEL = 10;
            
            // New: Dreamlo URLs
            // Fixed: Use a proxy to bypass mixed-content (http-from-https) errors.
            const PROXY_URL = "https://api.allorigins.win/raw?url=";
            const DREAMLO_PRIVATE_URL = "http://dreamlo.com/lb/srgh92_0dEeaf7Qj7DO6QQVLBfWgXzuUir6y2KByRwdA";
            const DREAMLO_PUBLIC_URL = "http://dreamlo.com/lb/6914145b8f40bcaa5cd2bb6e/json";

            const ACHIEVEMENTS_KEY = 'tetrisUltraAchievements';

            // --- 3. GAME STATE & VARIABLES ---
            let gameState = {
                board: [], currentPiece: null, nextPiece: null, holdPiece: null, canSwapHold: true,
                score: 0, lines: 0, level: 1, comboCounter: 0, isPaused: false, isGameOver: false,
                isTurbo: false, lastMoveWasRotate: false, currentScreen: 'start', lastScreen: 'start',
                lastTime: 0, dropCounter: 0, dropInterval: baseDropInterval, pieceTime: 0, pieceCount: 0,
                skillFactor: 1.0, konamiIndex: 0, particles: [], lineClearParticles: [],
            };
            let achievements = {
                'start': { name: 'Game On!', desc: 'Start your first game.', unlocked: false },
                'level5': { name: 'Getting Good', desc: 'Reach Level 5.', unlocked: false },
                'level10': { name: 'On Fire!', desc: 'Reach Level 10.', unlocked: false },
                'line10': { name: 'Line Clearer', desc: 'Clear 10 total lines.', unlocked: false },
                'tetris': { name: 'Tetris!', desc: 'Clear 4 lines at once.', unlocked: false },
                'tspin': { name: 'Twister', desc: 'Perform a T-Spin.', unlocked: false },
                'combo5': { name: 'Combo Master', desc: 'Get a 5x Combo.', unlocked: false },
                'perfect': { name: 'Perfection', desc: 'Achieve a Perfect Clear.', unlocked: false },
                'hold': { name: 'Saved For Later', desc: 'Use the Hold function.', unlocked: false },
                'ultra': { name: 'Going ULTRA', desc: 'Start a game on ULTRA difficulty.', unlocked: false },
            };
            const KONAMI_CODE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
            
            // New: Mobile gesture state
            let touchState = { startX: 0, startY: 0, moveX: 0, moveY: 0, isSwiping: false, lastMove: 0, lastTap: 0 };
            const isMobile = 'ontouchstart' in window;


            // --- 4. UI MANAGER ---
            class UIManager {
                constructor() {
                    this.currentScreen = 'start';
                    this.lastScreen = 'start';
                    this.activeScreenElement = screens.start;
                    this.achievementQueue = [];
                }
                
                showScreen(screenName, skipFade = false) {
                    if (this.currentScreen === screenName && !skipFade) return;

                    this.lastScreen = this.currentScreen;
                    this.currentScreen = screenName;
                    
                    const newScreenElement = screens[screenName];
                    const fadeDuration = skipFade ? 0 : 300;
                    
                    // Fade out old screen
                    if (this.activeScreenElement) {
                        if (skipFade) this.activeScreenElement.classList.remove('active');
                        else this.activeScreenElement.classList.add('fade-out');
                    }
                    
                    // Special handling for game screen (which is always "under" modals)
                    if (screenName === 'game') {
                        screens.game.classList.add('active'); // Show game screen
                    } else if (screenName !== 'pause' && screenName !== 'gameOver') {
                        // If moving to a menu (not pause), hide game screen
                        screens.game.classList.remove('active');
                    }

                    setTimeout(() => {
                        // Hide old screen
                        if (this.activeScreenElement && !skipFade) {
                            this.activeScreenElement.classList.remove('active');
                            this.activeScreenElement.classList.remove('fade-out');
                        }
                        
                        // Show new screen (if it's not the game screen)
                        if (screenName !== 'game') {
                            this.activeScreenElement = newScreenElement;
                            if (this.activeScreenElement) {
                                this.activeScreenElement.classList.add('active');
                            }
                        } else {
                            // If we're going *to* the game, there is no active "modal"
                            this.activeScreenElement = null; 
                        }
                        
                        this.onScreenChange(screenName);
                        
                    }, fadeDuration); // Must match CSS transition duration
                }
                
                onScreenChange(screenName) {
                    switch(screenName) {
                        case 'leaderboard': 
                            this.loadGlobalLeaderboard(); // Changed
                            break;
                        case 'achievements': this.renderAchievements(); break;
                        case 'gameOver': ui.finalScore.textContent = `Final Score: ${gameState.score}`; ui.playerNameInput.value = ''; break;
                        case 'settings':
                            settings.sound.checked = soundManager.isSoundEnabled();
                            settings.music.checked = soundManager.isMusicEnabled();
                            settings.difficulty.value = Object.keys(DIFFICULTIES).find(key => DIFFICULTIES[key] === baseDropInterval) || 'normal';
                            settings.theme.value = Object.keys(THEMES).find(key => THEMES[key] === currentTheme) || 'neon';
                            break;
                    }
                }

                updateGameUI() {
                    ui.score.textContent = gameState.score;
                    ui.level.textContent = gameState.level;
                    ui.lines.textContent = gameState.lines;
                    ui.combo.textContent = gameState.comboCounter > 1 ? `${gameState.comboCounter}x` : '0';
                    // New: Combo Aura
                    if (gameState.comboCounter >= 3) { gameCanvas.classList.add('combo-active'); } 
                    else { gameCanvas.classList.remove('combo-active'); }
                }

                // Modified to accept scores and add styling
                renderLeaderboard(scores = []) {
                    ui.leaderboardList.innerHTML = '';
                    if (!scores || scores.length === 0) { 
                        ui.leaderboardList.innerHTML = '<li><span class="name">No scores yet!</span></li>'; 
                        return; 
                    }
                    scores.forEach((entry, index) => {
                        const li = document.createElement('li');
                        // New: Add top-3 class
                        if (index < 3) {
                            li.classList.add('top-3');
                        }
                        // Dreamlo provides 'name', 'score'
                        li.innerHTML = `<span class="rank">${index + 1}.</span><span class="name">${entry.name}</span><span class="score">${entry.score}</span>`;
                        ui.leaderboardList.appendChild(li);
                    });
                }

                // New: Fetches from Dreamlo
                loadGlobalLeaderboard() {
                    ui.leaderboardList.innerHTML = '<li><span class="name">Loading...</span></li>';
                    // Fixed: Use proxy for mixed-content
                    const fetchUrl = PROXY_URL + encodeURIComponent(DREAMLO_PUBLIC_URL);
                    fetch(fetchUrl, { mode: 'cors' })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                            return response.json();
                        })
                        .then(data => {
                            const scores = data?.dreamlo?.leaderboard?.entry || [];
                            this.renderLeaderboard(scores);
                        })
                        .catch(error => {
                            console.error("Error loading leaderboard:", error);
                            ui.leaderboardList.innerHTML = '<li><span class="name">Error loading scores.</span></li>';
                        });
                }

                // New: Submits to Dreamlo
                submitGlobalScore(name, score) {
                    const saneName = encodeURIComponent(name);
                    // Fixed: Use proxy for mixed-content
                    const submitUrl = `${DREAMLO_PRIVATE_URL}/add/${saneName}/${score}`;
                    const fetchUrl = PROXY_URL + encodeURIComponent(submitUrl);
                    
                    // We don't wait for this, just send and forget
                    fetch(fetchUrl, { mode: 'cors' })
                        .then(response => {
                            if (response.ok) {
                                console.log("Score submitted successfully.");
                            } else {
                                console.warn("Score submission failed.", response);
                            }
                        })
                        .catch(error => {
                            console.error("Error submitting score:", error);
                        });
                }

                loadAchievements() { /* ... (unchanged) ... */ try { const data = localStorage.getItem(ACHIEVEMENTS_KEY); if (data) { const saved = JSON.parse(data); for (const key in achievements) { if (saved[key]) { achievements[key].unlocked = saved[key].unlocked; } } } } catch (e) { console.error("Could not load achievements:", e); } }
                saveAchievements() { /* ... (unchanged) ... */ try { localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify(achievements)); } catch (e) { console.error("Could not save achievements:", e); } }
                
                unlockAchievement(id) {
                    if (achievements[id] && !achievements[id].unlocked) {
                        achievements[id].unlocked = true; this.saveAchievements(); this.achievementQueue.push(id);
                        if (!ui.achievementPopup.classList.contains('show')) { this.showNextAchievement(); }
                    }
                }
                showNextAchievement() {
                    if (this.achievementQueue.length === 0) return;
                    const id = this.achievementQueue.shift(); const ach = achievements[id];
                    ui.achievementTitle.textContent = ach.name; ui.achievementDesc.textContent = ach.desc;
                    ui.achievementPopup.classList.add('show');
                    setTimeout(() => { ui.achievementPopup.classList.remove('show'); setTimeout(() => this.showNextAchievement(), 500); }, 5000);
                }
                renderAchievements() {
                    ui.achievementsList.innerHTML = '';
                    for (const id in achievements) {
                        const ach = achievements[id]; const li = document.createElement('li'); li.className = 'achievement-item';
                        if (ach.unlocked) li.classList.add('unlocked');
                        li.innerHTML = `<span class="name">${ach.name}</span><span class="desc">${ach.desc}</span><span class="status">${ach.unlocked ? 'UNLOCKED' : 'LOCKED'}</span>`;
                        ui.achievementsList.appendChild(li);
                    }
                }
                triggerScreenShake() {
                    if (gameContainer.classList.contains('shake')) { gameContainer.classList.remove('shake'); void gameContainer.offsetWidth; }
                    gameContainer.classList.add('shake');
                    setTimeout(() => { gameContainer.classList.remove('shake'); }, 400);
                }
            }
            const uiManager = new UIManager();
            
            // Inject Achievement CSS
            const styleSheet = document.createElement("style"); styleSheet.type = "text/css";
            styleSheet.innerText = `#achievements-list { list-style: none; width: 100%; display: flex; flex-direction: column; gap: 1rem; max-height: 40vh; overflow-y: auto; } .achievement-item { display: flex; flex-wrap: wrap; justify-content: space-between; padding: 1rem; background: rgba(255, 0, 0, 0.1); border-radius: var(--border-radius-s); border: 1px solid rgba(255, 0, 0, 0.2); } .achievement-item .name { font-size: 1.2rem; color: var(--text-dim); width: 100%; } .achievement-item .desc { font-size: 0.9rem; color: var(--text-dim); opacity: 0.7; } .achievement-item .status { font-size: 1rem; font-weight: 700; color: #f00; } .achievement-item.unlocked { background: rgba(0, 255, 255, 0.1); border-color: rgba(0, 255, 255, 0.2); } .achievement-item.unlocked .name { color: var(--color-primary); } .achievement-item.unlocked .desc { color: var(--color-primary); } .achievement-item.unlocked .status { color: var(--color-tertiary); }`;
            document.head.appendChild(styleSheet);


            // --- 5. SOUND MANAGER (v3.3) ---
            class SoundManager {
                constructor() {
                    this.audioCtx = null;
                    this.soundEnabled = true;
                    this.musicEnabled = true;
                    // Gain Nodes
                    this.masterSoundGain = null;
                    this.masterMusicGain = null;
                    this.kickGain = null; this.snareGain = null; this.hatGain = null;
                    this.bassGain = null; this.ambientGain = null;
                    
                    this.panner = null; // Piece FX panner
                    // New: Panners for music
                    this.ambientPanner = null; 
                    this.bassPanner = null;
                    
                    this.speech = window.speechSynthesis;
                    this.voice = null;
                    
                    // Music Engine
                    this.beatInterval = null;
                    this.currentBeat = 0;
                    this.tempo = 120; // bpm
                    this.bassOsc = null;
                    this.ambientOsc = null;
                    
                    this.loadVoice();
                }
                
                loadVoice() {
                    if (!this.speech) return;
                    const getVoices = () => {
                        const voices = this.speech.getVoices();
                        this.voice = voices.find(v => v.name.includes('Google') || v.name.includes('Microsoft') || v.lang.startsWith('en')) || voices[0];
                    };
                    getVoices();
                    if (this.speech.onvoiceschanged !== undefined) {
                        this.speech.onvoiceschanged = getVoices;
                    }
                }
                
                init() {
                    if (this.audioCtx) return;
                    try {
                        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        const now = this.audioCtx.currentTime;
                        
                        // --- Sound FX Chain ---
                        this.masterSoundGain = this.audioCtx.createGain();
                        this.masterSoundGain.gain.setValueAtTime(this.soundEnabled ? 0.5 : 0, now);
                        
                        this.panner = this.audioCtx.createStereoPanner();
                        this.panner.pan.setValueAtTime(0, now);
                        
                        this.panner.connect(this.masterSoundGain);
                        this.masterSoundGain.connect(this.audioCtx.destination);
                        
                        // --- Music Chain ---
                        this.masterMusicGain = this.audioCtx.createGain();
                        this.masterMusicGain.gain.setValueAtTime(this.musicEnabled ? 0 : 0, now); // Start silent
                        this.masterMusicGain.connect(this.audioCtx.destination);
                        
                        // Create individual track gains
                        this.kickGain = this.audioCtx.createGain(); this.kickGain.connect(this.masterMusicGain);
                        this.snareGain = this.audioCtx.createGain(); this.snareGain.connect(this.masterMusicGain);
                        this.hatGain = this.audioCtx.createGain(); this.hatGain.connect(this.masterMusicGain);
                        
                        // New: Panner for bass
                        this.bassPanner = this.audioCtx.createStereoPanner(); this.bassPanner.pan.setValueAtTime(-0.5, now); // Bass slightly left
                        this.bassGain = this.audioCtx.createGain(); 
                        this.bassGain.connect(this.bassPanner); this.bassPanner.connect(this.masterMusicGain);

                        // New: Panner for ambient
                        this.ambientPanner = this.audioCtx.createStereoPanner(); this.ambientPanner.pan.setValueAtTime(0.5, now); // Ambient slightly right
                        this.ambientGain = this.audioCtx.createGain(); 
                        this.ambientGain.connect(this.ambientPanner); this.ambientPanner.connect(this.masterMusicGain);
                        
                        this.kickGain.gain.value = 0.8;
                        this.snareGain.gain.value = 0.6;
                        this.hatGain.gain.value = 0.2;
                        this.bassGain.gain.value = 0.5;
                        this.ambientGain.gain.value = 0.1;
                        
                        this.startAmbientDrone();
                        
                    } catch(e) { console.error("Web Audio API is not supported", e); this.soundEnabled = false; this.musicEnabled = false; }
                }
                
                toggleSound(isEnabled) {
                    this.soundEnabled = isEnabled;
                    if (this.masterSoundGain) { this.masterSoundGain.gain.linearRampToValueAtTime(this.soundEnabled ? 0.5 : 0, this.audioCtx.currentTime + 0.1); }
                }
                toggleMusic(isEnabled) {
                    this.musicEnabled = isEnabled;
                    if (this.masterMusicGain) { this.masterMusicGain.gain.linearRampToValueAtTime(this.musicEnabled ? 0.15 : 0, this.audioCtx.currentTime + 0.5); }
                    if (isEnabled && !this.beatInterval) { this.startMusic(); }
                }
                pauseMusic() {
                    if (this.masterMusicGain && this.musicEnabled) { this.masterMusicGain.gain.linearRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.5); }
                }
                resumeMusic() {
                    if (this.masterMusicGain && this.musicEnabled) { this.masterMusicGain.gain.linearRampToValueAtTime(0.15, this.audioCtx.currentTime + 0.5); }
                }
                
                // Reactive Silence
                duckMusic(duration = 500) {
                    if (!this.masterMusicGain || !this.musicEnabled) return;
                    const now = this.audioCtx.currentTime;
                    const originalVolume = 0.15;
                    this.masterMusicGain.gain.cancelScheduledValues(now);
                    this.masterMusicGain.gain.setValueAtTime(this.masterMusicGain.gain.value, now);
                    this.masterMusicGain.gain.linearRampToValueAtTime(0.01, now + 0.05); // Duck quickly
                    this.masterMusicGain.gain.linearRampToValueAtTime(originalVolume, now + (duration / 1000)); // Return slowly
                }
                
                isSoundEnabled() { return this.soundEnabled; }
                isMusicEnabled() { return this.musicEnabled; }

                play(soundName) {
                    if (!this.soundEnabled || !this.audioCtx) return;
                    const now = this.audioCtx.currentTime;
                    let osc, gain;
                    try {
                        gain = this.audioCtx.createGain();
                        gain.connect(this.panner); // Connect to 3D panner
                        
                        switch(soundName) {
                            case 'rotate':
                                osc = this.audioCtx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(600, now);
                                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                                osc.connect(gain); osc.start(now); osc.stop(now + 0.05);
                                break;
                            case 'drop':
                                osc = this.audioCtx.createOscillator(); osc.type = 'square'; osc.frequency.setValueAtTime(200, now);
                                gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                                osc.connect(gain); osc.start(now); osc.stop(now + 0.1);
                                break;
                            case 'clear':
                                osc = this.audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                                gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                                osc.connect(gain); osc.start(now); osc.stop(now + 0.2);
                                break;
                            case 'tetris': 
                                osc = this.audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(1000, now); osc.frequency.exponentialRampToValueAtTime(1500, now + 0.4);
                                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                                osc.connect(gain); osc.start(now); osc.stop(now + 0.4);
                                break;
                            case 'gameOver':
                                osc = this.audioCtx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(500, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.8);
                                gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                                osc.connect(gain); osc.start(now); osc.stop(now + 0.8);
                                break;
                        }
                    } catch (e) { console.error("Error playing sound:", e); }
                }
                
                // Update piece panner
                updatePan(xPosition) {
                    if (!this.panner) return;
                    const pan = (xPosition / (COLS - 1)) * 1.6 - 0.8; // Map 0-9 to -0.8 to 0.8
                    this.panner.pan.linearRampToValueAtTime(pan, this.audioCtx.currentTime + 0.05);
                }
                
                // New: Update music panners based on camera
                updateMusicPan(cameraYPan) {
                    if (!this.bassPanner || !this.ambientPanner) return;
                    // Move bass/ambient in opposite directions to camera
                    this.bassPanner.pan.linearRampToValueAtTime(-0.5 - cameraYPan * 0.5, this.audioCtx.currentTime + 0.1);
                    this.ambientPanner.pan.linearRampToValueAtTime(0.5 - cameraYPan * 0.5, this.audioCtx.currentTime + 0.1);
                }
                
                playVoice(text) {
                    if (!this.soundEnabled || !this.speech) return;
                    try {
                        const utterance = new SpeechSynthesisUtterance(text);
                        if (this.voice) { utterance.voice = this.voice; }
                        utterance.pitch = 1.1;
                        utterance.rate = 1.2;
                        this.speech.speak(utterance);
                    } catch (e) {
                        console.error("Speech synthesis failed", e);
                    }
                }
                
                // --- Procedural Music Engine ---
                
                startAmbientDrone() {
                    if (!this.audioCtx) return;
                    const now = this.audioCtx.currentTime;
                    this.ambientOsc = this.audioCtx.createOscillator();
                    const lfo = this.audioCtx.createOscillator();
                    const lfoGain = this.audioCtx.createGain();
                    
                    this.ambientOsc.type = 'sine'; this.ambientOsc.frequency.setValueAtTime(55, now); // Low A
                    lfo.type = 'sine'; lfo.frequency.setValueAtTime(0.1, now); // Very slow
                    lfoGain.gain.setValueAtTime(0.01, now); // Subtle modulation
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(this.ambientGain.gain);
                    
                    this.ambientOsc.connect(this.ambientGain);
                    this.ambientOsc.start(now); lfo.start(now);
                }
                
                startMusic() {
                    if (!this.audioCtx || this.beatInterval) return;
                    const now = this.audioCtx.currentTime;
                    
                    this.bassOsc = this.audioCtx.createOscillator();
                    this.bassOsc.type = 'sawtooth';
                    this.bassOsc.connect(this.bassGain);
                    this.bassOsc.start(now);
                    
                    this.beatInterval = setInterval(() => {
                        const level = gameState.level;
                        if (this.musicEnabled) { this.playMusicBeat(level); }
                        this.currentBeat = (this.currentBeat + 1) % 16;
                        
                        // Trigger beat pulse
                        document.body.classList.add('beat-active');
                        setTimeout(() => document.body.classList.remove('beat-active'), 50);
                        
                    }, 60000 / this.tempo / 2); // 16th notes
                }
                
                stopMusic() {
                    if (this.beatInterval) { clearInterval(this.beatInterval); this.beatInterval = null; }
                    if (this.bassOsc) { this.bassOsc.stop(); this.bassOsc = null; }
                }
                
                updateMusic(level) {
                    this.tempo = 120 + (level * 4);
                    if (this.beatInterval) { // Restart interval with new tempo
                        this.stopMusic();
                        this.startMusic();
                    }
                }
                
                playMusicBeat(level) {
                    const now = this.audioCtx.currentTime;
                    
                    // Bassline (simple 16-step)
                    const bassPattern = [1,0,0,1, 0,1,0,0, 1,0,1,0, 1,0,1,0];
                    if (bassPattern[this.currentBeat] === 1) {
                        this.bassOsc.frequency.setValueAtTime(this.currentBeat % 4 === 0 ? 65 : 82, now); // C, E
                        this.bassGain.gain.setValueAtTime(0.5, now);
                        this.bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    }
                    
                    // Kick
                    if (this.currentBeat % 4 === 0) {
                        this.playDrum('kick', now, this.kickGain);
                    }
                    // Snare
                    if (this.currentBeat === 4 || this.currentBeat === 12) {
                        this.playDrum('snare', now, this.snareGain);
                    }
                    // Hi-hat
                    if (level > 2 && this.currentBeat % 2 === 0) {
                        this.playDrum('hihat', now, this.hatGain);
                    }
                    // Open hi-hat
                    if (level > 5 && this.currentBeat === 14) {
                        this.playDrum('openhat', now, this.hatGain);
                    }
                }
                
                playDrum(type, time, destination) {
                    let osc, gain;
                    osc = this.audioCtx.createOscillator(); gain = this.audioCtx.createGain();
                    osc.connect(gain); gain.connect(destination);
                    
                    switch(type) {
                        case 'kick':
                            osc.type = 'sine'; osc.frequency.setValueAtTime(120, time); osc.frequency.exponentialRampToValueAtTime(50, time + 0.1);
                            gain.gain.setValueAtTime(1, time); gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                            break;
                        case 'snare':
                            osc.type = 'triangle'; osc.frequency.setValueAtTime(250, time);
                            gain.gain.setValueAtTime(0.8, time); gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                            // Add noise
                            const noise = this.audioCtx.createBufferSource();
                            const buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * 0.1, this.audioCtx.sampleRate);
                            const data = buffer.getChannelData(0);
                            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                            noise.buffer = buffer; noise.connect(gain); noise.start(time); noise.stop(time + 0.1);
                            break;
                        case 'hihat':
                            osc.type = 'square'; osc.frequency.setValueAtTime(2000, time);
                            gain.gain.setValueAtTime(1, time); gain.gain.exponentialRampToValueAtTime(0.01, time + 0.03);
                            break;
                        case 'openhat':
                            osc.type = 'square'; osc.frequency.setValueAtTime(2000, time);
                            gain.gain.setValueAtTime(1, time); gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                            break;
                    }
                    osc.start(time); osc.stop(time + 0.2);
                }
            }
            const soundManager = new SoundManager();


            // --- 6. CANVAS RENDERER ---
            class Renderer {
                constructor() { this.colors = currentTheme; }
                
                setTheme(themeName) {
                    this.colors = THEMES[themeName] || THEMES.neon;
                    currentTheme = this.colors;
                    
                    // Update CSS vars for theme
                    const root = document.documentElement;
                    root.style.setProperty('--color-primary', this.colors[1] || '#00ffff');
                    root.style.setProperty('--color-secondary', this.colors[3] || '#ff00ff');
                    root.style.setProperty('--color-tertiary', this.colors[2] || '#ffff00');
                    
                    if (uiManager.currentScreen === 'game' && !gameState.isPaused) {
                         this.draw();
                         this.drawNextPiece();
                         this.drawHoldPiece();
                    }
                }
                
                drawBlock(ctx, x, y, color, size, isGhost = false) {
                    if (color === THEMES.neon[0]) return; // Don't draw empty
                    const B = size; const X = x * B; const Y = y * B;
                    ctx.save();
                    if (isGhost) {
                        ctx.globalAlpha = 0.3; ctx.strokeStyle = color;
                        ctx.lineWidth = 2; ctx.strokeRect(X + 1, Y + 1, B - 2, B - 2);
                    } else {
                        // Main block
                        ctx.fillStyle = color;
                        ctx.shadowColor = color; ctx.shadowBlur = 15;
                        ctx.fillRect(X, Y, B, B);
                        
                        // Inner gradient
                        const gradient = ctx.createLinearGradient(X, Y, X + B, Y + B);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.0)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(X, Y, B, B);

                        // Subtle border
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(X, Y, B, B);
                    }
                    ctx.restore();
                }

                drawGrid(ctx) {
                    ctx.save(); ctx.strokeStyle = this.colors.grid; ctx.lineWidth = 1;
                    for (let x = 1; x < COLS; x++) { ctx.beginPath(); ctx.moveTo(x * BLOCK_SIZE, 0); ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE); ctx.stroke(); }
                    for (let y = 1; y < ROWS; y++) { ctx.beginPath(); ctx.moveTo(0, y * BLOCK_SIZE); ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE); ctx.stroke(); }
                    ctx.restore();
                }

                drawBoard() {
                    for (let y = 0; y < ROWS; y++) { for (let x = 0; x < COLS; x++) { const blockType = gameState.board[y][x]; if (blockType !== 0) { this.drawBlock(gameCtx, x, y, this.colors[blockType], BLOCK_SIZE); } } }
                }

                drawPiece(piece) {
                    const color = this.colors[piece.type];
                    piece.shape.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { this.drawBlock(gameCtx, piece.x + x, piece.y + y, color, BLOCK_SIZE); } }); });
                }

                drawGhostPiece() {
                    if (!gameState.currentPiece) return;
                    const ghost = { ...gameState.currentPiece }; const color = this.colors[ghost.type];
                    // Move ghost down
                    while (game.isValidMove(ghost.shape, ghost.x, ghost.y + 1)) { ghost.y++; }
                    // Draw ghost
                    ghost.shape.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { this.drawBlock(gameCtx, ghost.x + x, ghost.y + y, color, BLOCK_SIZE, true); } }); });
                }
                
                drawNextPiece() { this.drawInfoPiece(nextCtx, gameState.nextPiece, NEXT_CANVAS_SIZE); }
                drawHoldPiece() { this.drawInfoPiece(holdCtx, gameState.holdPiece, HOLD_CANVAS_SIZE, !gameState.canSwapHold); }

                drawInfoPiece(ctx, piece, canvasSize, isDisabled = false) {
                    ctx.clearRect(0, 0, canvasSize, canvasSize); if (!piece) return;
                    const color = this.colors[piece.type]; const B = canvasSize / 4; // 4x4 grid
                    const shape = piece.shape;
                    const w = shape[0].length; const h = shape.length;
                    const offsetX = (4 - w) / 2; const offsetY = (4 - h) / 2;
                    if (isDisabled) ctx.globalAlpha = 0.3;
                    shape.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { this.drawBlock(ctx, offsetX + x, offsetY + y, color, B); } }); });
                    ctx.globalAlpha = 1.0;
                }

                draw() {
                    gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                    gameCtx.shadowColor = 'transparent'; gameCtx.shadowBlur = 0;
                    this.drawGrid(gameCtx);
                    this.drawBoard();
                    if (gameState.currentPiece) {
                        this.drawGhostPiece();
                        this.drawPiece(gameState.currentPiece);
                    }
                    this.drawParticles(gameCtx, gameState.lineClearParticles); // Draw line clears
                    this.drawParticles(gameCtx, gameState.particles); // Draw trails
                }
                
                // Amplified particles
                createLineClearParticles(y, lines, isTetrisOrTSpin) {
                    const particleCount = lines * (isTetrisOrTSpin ? 200 : 30); // More particles
                    const color = isTetrisOrTSpin ? '255, 255, 0' : '255, 255, 255';
                    for (let i = 0; i < particleCount; i++) {
                        gameState.lineClearParticles.push({
                            x: Math.random() * gameCanvas.width,
                            y: (y + Math.random()) * BLOCK_SIZE,
                            vx: (Math.random() - 0.5) * (isTetrisOrTSpin ? 15 : 5), // More velocity
                            vy: (Math.random() - 0.5) * (isTetrisOrTSpin ? 15 : 5), // More velocity
                            life: isTetrisOrTSpin ? 100 : 50, // Longer life
                            color: `rgba(${color}, ${Math.random() * 0.5 + 0.5})`
                        });
                    }
                }
                
                createPieceTrail() {
                    if (!gameState.currentPiece) return;
                    const piece = gameState.currentPiece; const color = this.colors[piece.type];
                    piece.shape.forEach((row, y) => { row.forEach((value, x) => {
                        if (value !== 0) { gameState.particles.push({
                            x: (piece.x + x + Math.random()) * BLOCK_SIZE,
                            y: (piece.y + y + Math.random()) * BLOCK_SIZE,
                            vx: (Math.random() - 0.5) * 1,
                            vy: (Math.random() - 0.5) * 1 - 0.5,
                            life: 20, color: color
                        }); }
                    }); });
                }

                updateParticles(particleArray) {
                    for (let i = particleArray.length - 1; i >= 0; i--) {
                        const p = particleArray[i];
                        p.x += p.vx; p.y += p.vy; p.life--;
                        if (p.life <= 0) { particleArray.splice(i, 1); }
                    }
                }

                drawParticles(ctx, particleArray) {
                    ctx.save();
                    particleArray.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life / 50; // Fade out
                        ctx.shadowColor = p.color; ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, Math.random() * 2 + 1, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.restore();
                }
            }
            const renderer = new Renderer();


            // --- 7. GAME LOGIC (v4.0) ---
            class Game {
                constructor() {
                    this.gameLoop = this.gameLoop.bind(this);
                    this.animationFrameId = null;
                }
                createBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }
                
                createPiece(type) {
                    const p = type ? PIECES.find(p => p.name === type) : PIECES[Math.floor(Math.random() * PIECES.length)];
                    const shape = p.shape; const typeIndex = PIECES.indexOf(p) + 1;
                    return {
                        shape: shape, type: typeIndex, name: p.name,
                        x: Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2),
                        y: 0
                    };
                }

                spawnPiece() {
                    gameState.currentPiece = gameState.nextPiece || this.createPiece();
                    gameState.nextPiece = this.createPiece();
                    renderer.drawNextPiece();
                    gameState.dropCounter = 0;
                    gameState.canSwapHold = true;
                    gameState.lastMoveWasRotate = false;
                    gameState.pieceTime = performance.now();
                    gameState.pieceCount++;
                    if (!this.isValidMove(gameState.currentPiece.shape, gameState.currentPiece.x, gameState.currentPiece.y)) {
                        this.gameOver();
                    }
                }

                rotatePiece(piece, direction) {
                    const shape = piece.shape; const N = shape.length;
                    const newShape = Array.from({ length: N }, () => Array(N).fill(0));
                    for (let y = 0; y < N; y++) {
                        for (let x = 0; x < N; x++) {
                            if (direction === 1) newShape[x][N - 1 - y] = shape[y][x]; // Clockwise
                            else newShape[N - 1 - x][y] = shape[y][x]; // Counter-clockwise
                        }
                    }
                    return newShape;
                }

                handleRotate(direction) {
                    if (!gameState.currentPiece) return;
                    const newShape = this.rotatePiece(gameState.currentPiece, direction);
                    let newX = gameState.currentPiece.x; let newY = gameState.currentPiece.y;

                    // Wall kick logic
                    if (!this.isValidMove(newShape, newX, newY)) {
                        if (this.isValidMove(newShape, newX - 1, newY)) newX--; // Try left
                        else if (this.isValidMove(newShape, newX + 1, newY)) newX++; // Try right
                        else if (this.isValidMove(newShape, newX, newY - 1)) newY--; // Try up (for T-Spin)
                        else return; // Can't rotate
                    }
                    
                    gameState.currentPiece.shape = newShape;
                    gameState.currentPiece.x = newX;
                    gameState.currentPiece.y = newY;
                    gameState.lastMoveWasRotate = true;
                    soundManager.play('rotate');
                    soundManager.updatePan(gameState.currentPiece.x);
                }
                
                handleMove(dx, dy) {
                    if (!gameState.currentPiece) return;
                    const newX = gameState.currentPiece.x + dx; const newY = gameState.currentPiece.y + dy;
                    if (this.isValidMove(gameState.currentPiece.shape, newX, newY)) {
                        gameState.currentPiece.x = newX;
                        gameState.currentPiece.y = newY;
                        if (dy > 0) { // Soft drop
                            gameState.score += SCORE_VALUES.softDrop;
                            gameState.dropCounter = 0; // Reset timer on move
                        }
                        gameState.lastMoveWasRotate = false;
                        if (dx !== 0) soundManager.updatePan(gameState.currentPiece.x); // Update 3D pan
                        return true;
                    }
                    return false;
                }
                
                // Hard Drop with Reactive Silence
                hardDrop() {
                    if (!gameState.currentPiece) return;
                    
                    let dropCount = 0;
                    const ghost = { ...gameState.currentPiece };
                    while (this.isValidMove(ghost.shape, ghost.x, ghost.y + 1)) {
                        ghost.y++;
                        dropCount++;
                    }
                    
                    // Check for reactive silence
                    const { lines, tspin } = this.predictClear(ghost);
                    if (lines >= 4 || (tspin && lines > 0)) {
                        soundManager.duckMusic(400); // Duck for 400ms
                    }
                    
                    // Now do the actual move
                    while (this.handleMove(0, 1)) { /* empty */ }
                    
                    gameState.score += dropCount * SCORE_VALUES.hardDrop;
                    this.lockPiece();
                    soundManager.play('drop');
                }
                
                // Helper for hardDrop silence check
                predictClear(piece) {
                    const testBoard = gameState.board.map(row => [...row]);
                    piece.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value !== 0) {
                                const boardX = piece.x + x;
                                const boardY = piece.y + y;
                                if (boardY >= 0 && boardX >= 0 && boardX < COLS && boardY < ROWS) {
                                    testBoard[boardY][boardX] = piece.type;
                                }
                            }
                        });
                    });
                    
                    let linesCleared = 0;
                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (testBoard[y].every(cell => cell !== 0)) {
                            linesCleared++;
                        }
                    }
                    
                    const tspin = (piece.name === 'T' && gameState.lastMoveWasRotate);
                    
                    return { lines: linesCleared, tspin: tspin };
                }
                
                handleHold() {
                    if (!gameState.canSwapHold || !gameState.currentPiece) return;
                    uiManager.unlockAchievement('hold');
                    const temp = gameState.currentPiece;
                    if (gameState.holdPiece) {
                        gameState.currentPiece = this.createPiece(gameState.holdPiece.name);
                    } else {
                        // First hold, need to spawn next piece
                        this.spawnPiece(); // This will be recursive, but just once
                        gameState.currentPiece = gameState.nextPiece;
                        gameState.nextPiece = this.createPiece();
                        renderer.drawNextPiece();
                    }
                    gameState.holdPiece = this.createPiece(temp.name); // Hold the piece
                    gameState.canSwapHold = false;
                    renderer.drawHoldPiece();
                }

                isValidMove(shape, x, y) {
                    for (let row = 0; row < shape.length; row++) {
                        for (let col = 0; col < shape[row].length; col++) {
                            if (shape[row][col] !== 0) {
                                const newX = x + col;
                                const newY = y + row;
                                // Check boundaries
                                if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
                                // Check collision with board (only if inside board)
                                if (newY >= 0 && gameState.board[newY][newX] !== 0) return false;
                            }
                        }
                    }
                    return true;
                }

                lockPiece() {
                    if (!gameState.currentPiece) return;
                    
                    const piece = gameState.currentPiece;
                    let tspinType = this.checkTSpin(piece);
                    
                    this.updateAdaptiveDifficulty(); // Check skill before locking
                    
                    piece.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value !== 0) {
                                const boardX = piece.x + x;
                                const boardY = piece.y + y;
                                if (boardY >= 0) { // Don't lock pieces above the board
                                    gameState.board[boardY][boardX] = piece.type;
                                }
                            }
                        });
                    });

                    gameState.currentPiece = null; // Piece is locked
                    
                    const linesCleared = this.clearLines();
                    const perfectClear = this.checkPerfectClear();
                    
                    this.updateScore(linesCleared, tspinType, perfectClear);
                    
                    if (linesCleared > 0 || tspinType) {
                        uiManager.triggerScreenShake();
                    }
                    
                    this.spawnPiece(); // Spawn new piece
                    uiManager.updateGameUI();
                }

                checkTSpin(piece) {
                    if (piece.name !== 'T' || !gameState.lastMoveWasRotate) { return 0; }
                    
                    // T-piece center
                    const cx = piece.x + 1; const cy = piece.y + 1;
                    
                    // Check 4 corners
                    const corners = [
                        this.isOccupied(cx - 1, cy - 1), // Top-left
                        this.isOccupied(cx + 1, cy - 1), // Top-right
                        this.isOccupied(cx - 1, cy + 1), // Bottom-left
                        this.isOccupied(cx + 1, cy + 1)  // Bottom-right
                    ];
                    
                    const occupiedCorners = corners.filter(c => c).length;
                    
                    if (occupiedCorners >= 3) {
                        uiManager.unlockAchievement('tspin');
                        return 1; // T-Spin
                    }
                    return 0;
                }

                isOccupied(x, y) {
                    if (x < 0 || x >= COLS || y >= ROWS) return true; // Outside is "occupied"
                    if (y < 0) return false; // Above board is not occupied
                    return gameState.board[y][x] !== 0;
                }
                
                checkPerfectClear() {
                    return gameState.board.every(row => row.every(cell => cell === 0));
                }

                clearLines() {
                    let linesCleared = 0;
                    let firstLineY = -1;
                    
                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (gameState.board[y].every(cell => cell !== 0)) {
                            if (firstLineY === -1) firstLineY = y;
                            linesCleared++;
                            gameState.board.splice(y, 1); // Remove line
                            gameState.board.unshift(Array(COLS).fill(0)); // Add empty line at top
                            y++; // Check the new line at this index
                        }
                    }
                    
                    if (linesCleared > 0) {
                        gameState.comboCounter++;
                        const isSpecial = linesCleared === 4 || gameState.lastMoveWasRotate; // T-Spin or Tetris
                        renderer.createLineClearParticles(firstLineY, linesCleared, isSpecial);
                        soundManager.play(linesCleared === 4 ? 'tetris' : 'clear');
                    } else {
                        gameState.comboCounter = 0; // Reset combo
                    }
                    
                    return linesCleared;
                }

                updateScore(linesCleared, tspinType, perfectClear) {
                    let lineScore = 0;
                    let voiceCall = null;

                    if (perfectClear) {
                        lineScore += SCORE_VALUES.perfectClear;
                        voiceCall = "Perfect Clear!";
                        uiManager.unlockAchievement('perfect');
                    }
                    
                    if (tspinType > 0) {
                        if (linesCleared === 1) lineScore += SCORE_VALUES.tspinSingle;
                        else if (linesCleared === 2) lineScore += SCORE_VALUES.tspinDouble;
                        else if (linesCleared === 3) lineScore += SCORE_VALUES.tspinTriple;
                        else lineScore += SCORE_VALUES.tspin; // T-Spin, no lines
                        voiceCall = "T-Spin";
                    } else {
                        if (linesCleared === 1) lineScore = SCORE_VALUES.single;
                        else if (linesCleared === 2) lineScore = SCORE_VALUES.double;
                        else if (linesCleared === 3) lineScore = SCORE_VALUES.triple;
                        else if (linesCleared >= 4) {
                            lineScore = SCORE_VALUES.tetris;
                            voiceCall = "Tetris!";
                            uiManager.unlockAchievement('tetris');
                        }
                    }

                    let comboBonus = (gameState.comboCounter > 1) ? (SCORE_VALUES.combo * gameState.comboCounter * gameState.level) : 0;
                    if (comboBonus > 0 && !voiceCall) {
                        voiceCall = `Combo ${gameState.comboCounter}`;
                    }
                    
                    gameState.score += (lineScore + comboBonus) * gameState.level;
                    gameState.lines += linesCleared;
                    
                    if (voiceCall) {
                        soundManager.playVoice(voiceCall);
                    }

                    const newLevel = Math.floor(gameState.lines / LINES_PER_LEVEL) + 1;
                    if (newLevel > gameState.level) {
                        gameState.level = newLevel;
                        soundManager.updateMusic(newLevel);
                    }
                    
                    // Update drop interval
                    gameState.dropInterval = (baseDropInterval * Math.pow(0.85, gameState.level - 1)) * gameState.skillFactor;
                    if (gameState.isTurbo) gameState.dropInterval = 50;

                    // Check achievements
                    if (gameState.level >= 5) uiManager.unlockAchievement('level5');
                    if (gameState.level >= 10) uiManager.unlockAchievement('level10');
                    if (gameState.lines >= 10) uiManager.unlockAchievement('line10');
                    if (gameState.comboCounter >= 5) uiManager.unlockAchievement('combo5');
                }
                
                updateAdaptiveDifficulty() {
                    const timeForPiece = (performance.now() - gameState.pieceTime) / 1000; // seconds
                    const targetTime = 2.0; // Target 2 sec per piece
                    if (timeForPiece < targetTime) {
                        // Player is fast, increase difficulty
                        gameState.skillFactor = Math.max(0.5, gameState.skillFactor * 0.99); // Capped at 50%
                    } else {
                        // Player is slow, decrease difficulty
                        gameState.skillFactor = Math.min(1.0, gameState.skillFactor * 1.01); // Capped at 100%
                    }
                }

                start() {
                    gameState.board = this.createBoard();
                    gameState.score = 0; gameState.lines = 0; gameState.level = 1;
                    gameState.comboCounter = 0; gameState.holdPiece = null;
                    gameState.canSwapHold = true; gameState.isGameOver = false; gameState.isPaused = false;
                    gameState.skillFactor = 1.0; gameState.pieceCount = 0;
                    gameState.dropInterval = baseDropInterval;
                    
                    if (baseDropInterval === DIFFICULTIES.ultra) { uiManager.unlockAchievement('ultra'); }
                    if (gameState.isTurbo) gameState.dropInterval = 50;
                    
                    this.spawnPiece(); // This sets nextPiece
                    this.spawnPiece(); // This sets currentPiece and a new nextPiece
                    
                    renderer.drawHoldPiece();
                    
                    uiManager.showScreen('game');
                    uiManager.updateGameUI();
                    
                    soundManager.resumeMusic();
                    if (!soundManager.beatInterval) soundManager.startMusic();
                    
                    uiManager.unlockAchievement('start');
                    
                    gameState.lastTime = 0;
                    if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = requestAnimationFrame(this.gameLoop);
                }
                
                pause() {
                    if (gameState.isGameOver) return;
                    gameState.isPaused = true;
                    soundManager.pauseMusic();
                    uiManager.showScreen('pause');
                    if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; }
                }
                
                resume() {
                    if (gameState.isGameOver) return;
                    gameState.isPaused = false;
                    soundManager.resumeMusic();
                    uiManager.showScreen('game');
                    gameState.lastTime = performance.now(); 
                    if (!this.animationFrameId) { this.animationFrameId = requestAnimationFrame(this.gameLoop); }
                }
                
                gameOver() {
                    gameState.isGameOver = true;
                    gameState.isPaused = true; // Stop game loop
                    soundManager.stopMusic();
                    soundManager.play('gameOver');
                    uiManager.showScreen('gameOver');
                    if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; }
                }
                
                quit() {
                    gameState.isPaused = true;
                    soundManager.stopMusic();
                    if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; }
                    screens.game.classList.remove('active'); // Manually hide game screen
                    uiManager.showScreen('menu');
                }

                gameLoop(timestamp) {
                    if (gameState.isPaused || gameState.isGameOver) return;
                    
                    const deltaTime = timestamp - gameState.lastTime;
                    gameState.lastTime = timestamp;
                    
                    gameState.dropCounter += deltaTime;
                    
                    if (gameState.dropCounter > gameState.dropInterval) {
                        if (!this.handleMove(0, 1)) { // If move down fails
                            this.lockPiece();
                        }
                        gameState.dropCounter = 0;
                    }
                    
                    // Update particles
                    renderer.updateParticles(gameState.lineClearParticles);
                    renderer.updateParticles(gameState.particles);
                    if (Math.random() < 0.3) { // Create trails
                        renderer.createPieceTrail();
                    }
                    
                    renderer.draw(); // Redraw everything
                    
                    this.animationFrameId = requestAnimationFrame(this.gameLoop);
                }
            }
            const game = new Game();
            
            
            // --- 8. INPUT HANDLERS (v3.3) ---
            function handleKeyDown(e) {
                // Konami Code
                if (e.key === KONAMI_CODE[gameState.konamiIndex]) {
                    gameState.konamiIndex++;
                    if (gameState.konamiIndex === KONAMI_CODE.length) {
                        alert('TURBO MODE ACTIVATED!');
                        gameState.isTurbo = true;
                        gameState.konamiIndex = 0;
                        if (uiManager.currentScreen === 'game' && !gameState.isPaused) {
                            gameState.dropInterval = 50;
                        }
                    }
                } else {
                    gameState.konamiIndex = 0;
                }
                
                if (e.target.tagName === 'INPUT') return; // Don't control game while typing name

                if (uiManager.currentScreen === 'game' && !gameState.isPaused) {
                    switch(e.key) {
                        case 'ArrowLeft': case 'a': game.handleMove(-1, 0); break;
                        case 'ArrowRight': case 'd': game.handleMove(1, 0); break;
                        case 'ArrowDown': case 's': game.handleMove(0, 1); break;
                        case 'ArrowUp': case 'w': case 'x': game.handleRotate(1); break;
                        case 'z': game.handleRotate(-1); break;
                        case ' ': e.preventDefault(); game.hardDrop(); break;
                        case 'c': case 'Shift': game.handleHold(); break;
                        case 'p': game.pause(); break;
                        case 'r': game.start(); break;
                    }
                } else {
                     // Global keys
                     switch(e.key) {
                         case 'p':
                             if (uiManager.currentScreen === 'pause') game.resume();
                             break;
                         case 'Escape':
                             if (uiManager.currentScreen === 'game') game.pause();
                             else if (uiManager.currentScreen === 'pause') game.resume();
                             else if (uiManager.currentScreen === 'settings') uiManager.showScreen(uiManager.lastScreen);
                             else if (uiManager.currentScreen === 'leaderboard') uiManager.showScreen(uiManager.lastScreen);
                             else if (uiManager.currentScreen === 'howToPlay') uiManager.showScreen(uiManager.lastScreen);
                             else if (uiManager.currentScreen === 'achievements') uiManager.showScreen(uiManager.lastScreen);
                             break;
                     }
                }
            }
            
            function setupTouchControls() {
                if (!isMobile) return;
                
                touch.controls.style.display = 'block'; // Show button controls
                
                // Button controls
                touch.left.addEventListener('touchstart', (e) => { e.preventDefault(); game.handleMove(-1, 0); }, { passive: false });
                touch.right.addEventListener('touchstart', (e) => { e.preventDefault(); game.handleMove(1, 0); }, { passive: false });
                touch.rotate.addEventListener('touchstart', (e) => { e.preventDefault(); game.handleRotate(1); }, { passive: false });
                touch.hold.addEventListener('touchstart', (e) => { e.preventDefault(); game.handleHold(); }, { passive: false });
                
                let downInterval = null;
                touch.down.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    game.handleMove(0, 1); // Move once
                    if (downInterval) clearInterval(downInterval);
                    downInterval = setInterval(() => { game.handleMove(0, 1); }, 100);
                }, { passive: false });
                touch.down.addEventListener('touchend', () => { if (downInterval) clearInterval(downInterval); downInterval = null; });
                
                // New: Gesture controls (on the game canvas)
                gameCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchState.startX = e.touches[0].clientX;
                    touchState.startY = e.touches[0].clientY;
                    touchState.isSwiping = false;
                    touchState.lastMove = Date.now();
                }, { passive: false });

                gameCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!e.touches[0]) return;
                    touchState.moveX = e.touches[0].clientX - touchState.startX;
                    touchState.moveY = e.touches[0].clientY - touchState.startY;
                    
                    // Horizontal swipe
                    const moveThreshold = BLOCK_SIZE * 0.8;
                    const now = Date.now();
                    if (Math.abs(touchState.moveX) > moveThreshold && (now - touchState.lastMove) > 100) {
                        if (touchState.moveX > 0) game.handleMove(1, 0);
                        else game.handleMove(-1, 0);
                        touchState.startX = e.touches[0].clientX; // Reset start
                        touchState.lastMove = now;
                        touchState.isSwiping = true;
                    }
                    
                    // Soft drop swipe
                    if (touchState.moveY > moveThreshold && (now - touchState.lastMove) > 100) {
                        game.handleMove(0, 1);
                        touchState.startY = e.touches[0].clientY; // Reset start
                        touchState.lastMove = now;
                        touchState.isSwiping = true;
                    }

                }, { passive: false });
                
                gameCanvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    const isSwipe = Math.abs(touchState.moveX) > (BLOCK_SIZE * 0.5) || Math.abs(touchState.moveY) > (BLOCK_SIZE * 0.5);
                    const now = Date.now();
                    
                    if (!isSwipe) {
                        // It's a tap
                        game.handleRotate(1);
                        
                        // Check for double tap (hard drop)
                        if (now - touchState.lastTap < 300) {
                            game.hardDrop();
                        }
                        touchState.lastTap = now;
                    } else {
                        // Check for swipe down (hard drop)
                        if (touchState.moveY > BLOCK_SIZE * 2 && Math.abs(touchState.moveX) < BLOCK_SIZE) {
                            game.hardDrop();
                        }
                    }

                    touchState.isSwiping = false;
                    touchState.moveX = 0; touchState.moveY = 0;
                }, { passive: false });
            }

            // --- 9. BUTTON EVENT LISTENERS ---
            function setupButtonListeners() {
                // --- Start Screen ---
                buttons.startPlay.onclick = () => {
                    soundManager.init(); // IMPORTANT: First user interaction
                    uiManager.showScreen('menu');
                };
                buttons.startSettings.onclick = () => uiManager.showScreen('settings');
                
                // --- Main Menu ---
                buttons.menuNewGame.onclick = () => game.start();
                buttons.menuLeaderboard.onclick = () => uiManager.showScreen('leaderboard');
                buttons.menuHowToPlay.onclick = () => uiManager.showScreen('how-to-play-screen'); // Fixed: was 'howToPlay'
                buttons.menuSettings.onclick = () => uiManager.showScreen('settings');
                buttons.menuAchievements.onclick = () => uiManager.showScreen('achievements');
                
                // --- Pause Screen ---
                buttons.pauseResume.onclick = () => game.resume();
                buttons.pauseRestart.onclick = () => game.start();
                buttons.pauseQuit.onclick = () => game.quit();
                
                // --- Game Over Screen ---
                buttons.gameOverRestart.onclick = () => game.start();
                buttons.gameOverQuit.onclick = () => { screens.game.classList.remove('active'); uiManager.showScreen('menu'); }
                buttons.submitScore.onclick = () => {
                    let name = ui.playerNameInput.value.toUpperCase(); if (!name) name = 'PLAYER';
                    name = name.substring(0, 10); // Use 10 chars
                    
                    // Changed: Call submitGlobalScore
                    uiManager.submitGlobalScore(name, gameState.score);
                    
                    screens.game.classList.remove('active');
                    uiManager.showScreen('leaderboard'); // Show leaderboard after submit
                };
                
                // --- Other Modals ---
                buttons.leaderboardBack.onclick = () => uiManager.showScreen(uiManager.lastScreen);
                buttons.settingsBack.onclick = () => uiManager.showScreen(uiManager.lastScreen);
                buttons.howToPlayBack.onclick = () => uiManager.showScreen(uiManager.lastScreen);
                buttons.achievementsBack.onclick = () => uiManager.showScreen(uiManager.lastScreen);
                
                // --- In-Game ---
                buttons.pauseGame.onclick = () => game.pause();
                
                // --- Settings ---
                settings.sound.onchange = (e) => soundManager.toggleSound(e.target.checked);
                settings.music.onchange = (e) => soundManager.toggleMusic(e.target.checked);
                settings.difficulty.onchange = (e) => {
                    baseDropInterval = DIFFICULTIES[e.target.value] || DIFFICULTIES.normal;
                    // Update interval if game is running
                    if (uiManager.currentScreen === 'game' && !gameState.isPaused) {
                        gameState.dropInterval = baseDropInterval * Math.pow(0.85, gameState.level - 1) * gameState.skillFactor;
                        if (gameState.isTurbo) gameState.dropInterval = 50;
                    }
                };
                settings.theme.onchange = (e) => renderer.setTheme(e.target.value);
            }

            // --- 10. BACKGROUND ANIMATION ---
            let bgParticles = [];
            function createBgParticles() {
                bgParticles = [];
                const particleCount = Math.floor(bgCanvas.width * bgCanvas.height / 20000);
                for (let i = 0; i < particleCount; i++) {
                    bgParticles.push({
                        x: Math.random() * bgCanvas.width,
                        y: Math.random() * bgCanvas.height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        size: Math.random() * 2 + 1,
                        color: `rgba(0, 255, 255, ${Math.random() * 0.3 + 0.1})` // Faint cyan
                    });
                }
            }

            function animateBackground() {
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                
                bgParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    // Wrap around
                    if (p.x < 0) p.x = bgCanvas.width;
                    if (p.x > bgCanvas.width) p.x = 0;
                    if (p.y < 0) p.y = bgCanvas.height;
                    if (p.y > bgCanvas.height) p.y = 0;
                    
                    bgCtx.fillStyle = p.color;
                    bgCtx.beginPath();
                    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
                
                // Constellation lines
                bgCtx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
                bgCtx.lineWidth = 1;
                for (let i = 0; i < bgParticles.length; i++) {
                    for (let j = i + 1; j < bgParticles.length; j++) {
                        const dx = bgParticles[i].x - bgParticles[j].x;
                        const dy = bgParticles[i].y - bgParticles[j].y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 150) { // Connect if close
                            bgCtx.beginPath();
                            bgCtx.moveTo(bgParticles[i].x, bgParticles[i].y);
                            bgCtx.lineTo(bgParticles[j].x, bgParticles[j].y);
                            bgCtx.stroke();
                        }
                    }
                }
                
                requestAnimationFrame(animateBackground);
            }


            // --- 11. INITIALIZATION (v4.0) ---
            function resizeGame() { 
                const screenHeight = window.innerHeight;
                const screenWidth = window.innerWidth;
                
                // Resize BG canvas
                bgCanvas.width = screenWidth;
                bgCanvas.height = screenHeight;
                createBgParticles(); // Repopulate particles for new size
                
                const isMobileLayout = screenWidth <= 860;
                
                let gameAreaHeight, gameAreaWidth;
                
                if (isMobileLayout) {
                    gameAreaHeight = screenHeight * 0.9 - (isMobile ? 250 : 0); // Leave space for controls on mobile
                    gameAreaWidth = screenWidth * 0.9;
                } else {
                    gameAreaHeight = screenHeight * 0.8;
                    gameAreaWidth = screenWidth * 0.8 - 400; // Leave space for side panels
                }

                // Calculate block size
                const heightBasedBlockSize = Math.floor(gameAreaHeight / ROWS);
                const widthBasedBlockSize = Math.floor(gameAreaWidth / COLS);
                BLOCK_SIZE = Math.min(heightBasedBlockSize, widthBasedBlockSize);
                if (BLOCK_SIZE < 10) BLOCK_SIZE = 10; // Minimum size
                
                gameCanvas.width = COLS * BLOCK_SIZE;
                gameCanvas.height = ROWS * BLOCK_SIZE;
                
                // Resize info canvases
                const nextSize = isMobileLayout ? 80 : 120;
                nextCanvas.width = nextSize; nextCanvas.height = nextSize;
                holdCanvas.width = nextSize; holdCanvas.height = nextSize;
                
                // Resize info boxes to match canvas
                document.getElementById('next-piece-box').style.width = `${nextSize}px`;
                document.getElementById('next-piece-box').style.height = `${nextSize}px`;
                document.getElementById('hold-piece-box').style.width = `${nextSize}px`;
                document.getElementById('hold-piece-box').style.height = `${nextSize}px`;

                // Redraw game state if active
                if (uiManager.currentScreen === 'game' && !gameState.isPaused) {
                    renderer.draw();
                    renderer.drawNextPiece();
                    renderer.drawHoldPiece();
                }
            }
            
            function init() {
                console.log("Initializing TETRIS ULTRA v4.0 (Global)...");
                
                // Parallax, Cursor Light, and Camera Tilt
                window.addEventListener('mousemove', e => {
                    const x = e.clientX;
                    const y = e.clientY;
                    const root = document.documentElement;
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    
                    // Parallax
                    const moveX = (x / w - 0.5) * -30; // 30px max move
                    const moveY = (y / h - 0.5) * -30;
                    bgCanvas.style.transform = `translate(${moveX}px, ${moveY}px) translateZ(-500px) scale(1.5)`;
                    
                    // Cursor Light
                    root.style.setProperty('--mouse-x', `${x}px`);
                    root.style.setProperty('--mouse-y', `${y}px`);
                    
                    // Pulse light on move
                    root.style.setProperty('--cursor-light-size', '500px');
                    if(window.cursorTimeout) clearTimeout(window.cursorTimeout);
                    window.cursorTimeout = setTimeout(() => {
                        root.style.setProperty('--cursor-light-size', '400px');
                    }, 100);
                    
                    // Camera Tilt
                    const tiltY = (x / w - 0.5) * -10; // Max 5 deg
                    const tiltX = (y / h - 0.5) * 10; // Max 5 deg
                    root.style.setProperty('--camera-rotate-y', `${tiltY}deg`);
                    root.style.setProperty('--camera-rotate-x', `${tiltX}deg`);
                    soundManager.updateMusicPan(tiltY / 5); // Send normalized pan
                });
                
                window.addEventListener('resize', resizeGame);
                document.addEventListener('keydown', handleKeyDown);
                setupButtonListeners();
                setupTouchControls(); // Sets up both buttons and gestures
                
                uiManager.loadAchievements();
                
                // Time-of-day theme
                const hour = new Date().getHours();
                if (hour >= 20 || hour < 6) { // 8 PM - 6 AM
                    settings.theme.value = 'cyberpunk';
                } else if (hour >= 6 && hour < 12) { // 6 AM - 12 PM
                    settings.theme.value = 'pastel';
                } else { // 12 PM - 8 PM
                    settings.theme.value = 'neon';
                }
                
                renderer.setTheme(settings.theme.value);
                
                resizeGame(); // Initial size
                animateBackground(); // Start background loop
                
                uiManager.showScreen('start', true); // Show start screen immediately
            }
            
            init();

        });
    </script>

</body>
</html>
